---
date: 2018-09-30T00:00:00+00:00
title: 2018-09-30-logbook
description: Weekend logbook
tags:
  - logbook
  - bits
  - go
  - mariadb
weight: -210
---

# Logbook Structure

I'm going to start writing a logbook. In it will be a description of what I learned in the course of working on a side project that weekend. The idea comes to me as an easy way to recount what I did, share the lessons learned, and enforce more discipline in consistently working on my side projects.

I imagine it will look something like this:

* Summary
    * Task Item
        * Lessons learned
    * Task Item
        * Lessons learned

My goal for this blog is not to be useful only to me, but also for my notes to be useful to others who may be trying to learn the same things as myself. In that pursuit I will attempt to write with a simple and concise writing style without sacrificing too many details. Further, the key bits will be frontloaded so that a person can tell at a glance if this blog post is at all interesting to them.

> If you can't explain it simply, you don't understand it well enough.
> -misattributed to Albert Einstein

So, let me jump write into it:

# Summary
This week I made progress on setting up the skeleton of [folrep](https://github.com/thaniri/repotracker). This involved three concrete tasks.

1. Implement a logging library.
2. Implement a controller for an [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) web application.
3. Design a database scheme.

## Implementing a logging library

### What I learned

* The `:=` operator is not used for variable reassignment.
* Bitshifting and bit manipulation.

### Detail - Implementing a logging library

I had no intention of writing my own logging library, but was dissatisfied with the [log](https://golang.org/pkg/log/) package provided in the [standard library](https://golang.org/pkg/#stdlib).

My two points of concern were not having granular control of log levels, and not being able to control the rotation of my log files.

In total I tried three different logging libraries:

1. https://github.com/cihub/seelog
2. https://github.com/golang/glog
3. https://github.com/chasex/glog

I vetoed seelog quite quickly when I realized that the configuration was controlled by XML. Generally speaking I don't like the structure of XML because it is more verbose than something like JSON or YAML, and that makes it difficult to read. I don't like seeing lots of nested HTML tags like the era of front-end web development where `div`s were nested 10 layers deep.

The second package interested me a lot because it was inspired by Google engineers with https://github.com/google/glog, and those guys are pretty smart. However, this one also didn't make the cut for me because I was missing output formatting for my log file. While I haven't decided yet which date format I want to use for log entries going forward, I want to keep it an easy option for the future. Finally, github user chasex's implementation of glog checked off the last box that I wanted for my logging package.

So I did a `go get` and started running with the new package. The example was easy enough to follow. But I don't want to implement everything in `main.go`. So I made my own logging package, and my idea was that I would initialized a globally available logging object there, and access that object from anywhere else in my program to write a log entry.

Here was attempt #1

`rpLogger.go`
```
package rpLogger
import (
        "github.com/chasex/glog"
	"fmt"
	"io/ioutil"
)
var Logger glog.Logger
func init() {
	file, err := ioutil.ReadFile("./config/loggerConfig.json")
	fmt.Println(file)
        options := glog.LogOptions {
                File: "/var/log/folrep/folrep.log",
                Flag: glog.LstdFlags,
                Level: glog.Linfo,
                Mode: glog.R_Day,
        }
	Logger, err := glog.New(options)
        if err != nil {
                panic(err)
        }
	Logger.Info("Read config from file")
}
func Test() {
	Logger.Flush()
        Logger.Debug("hello world")
        Logger.Infof("hello, %s", "WORLD")
        Logger.Warn("testing message")
}
```

`main.go`
```
package main

import (
	"github.com/thaniri/repotracker-app/rpDatabase"
	"github.com/thaniri/repotracker-app/rpLogger"
)

func main() {
	defer rpLogger.Logger.Flush()
	rpLogger.Test()
	rpDatabase.Spam()
}
```

Here there are a couple of problems:

1. The global `var Logger glog.Logger` declaration is of a glog.Logger Type. This is an issue because when I call the `glog.New()` function, it returns a pointer and not an object.
2. When I call `glog.New()` I am using the `:=` operator to "assign" the return to my global Logger object. What I learned is that `:=` only ever creates _new_ variables, and doesn't do reassignments. So What I ended up doing is creating a Logger object in the scope of the `init()` function. Then when I call the global Logger object from main, I get a nil pointer panic because that object was never initialized.

What it looks like after being fixed up:

`rpLogger.go`
```
package rpLogger
import (
        "github.com/chasex/glog"
	"fmt"
	"io/ioutil"
)
var Logger *glog.Logger
func init() {
	file, err := ioutil.ReadFile("./config/loggerConfig.json")
	fmt.Println(file)
        options := glog.LogOptions {
                File: "/var/log/folrep/folrep.log",
                Flag: glog.LstdFlags,
                Level: glog.Linfo,
                Mode: glog.R_Day,
        }
	Logger, err = glog.New(options)
        if err != nil {
                panic(err)
        }
	Logger.Info("Read config from file")
}
func Test() {
	Logger.Flush()
        Logger.Debug("hello world")
        Logger.Infof("hello, %s", "WORLD")
        Logger.Warn("testing message")
}
```

Now I have something that least runs, but I continue to declare the configuration options in code. This would be much better being read from a configuration file.

`config/loggerConfig.json`
```
{
	"file": "/var/log/folrep.log",
	"flag": "glog.LstdFlags",
	"level": "glog.Linfo",
	"mode": "glog.R_day"
}
```

Seems pretty simple. Just unmarshal that json file and plug into into the `glog.LogOptions` struct and run with it. However, flag, level and mode are all `int` types. This got me to discover that a common pattern in Go programming for configurations is to use [bit shifting](https://www.hackerearth.com/practice/notes/bit-manipulation/) for setting certain options.

I didn't go ahead and do a PHD on bit manipulation, but I learned enough to get myself going. I'll take the flag option for explanation purposes. In the `glog` package, this option is controlled by a `const` of integers. It looks like this:

```
const (
	Ldate         = 1 << iota 
	Ltime                     
	Lmicroseconds             
	Llongfile                 
	Lshortfile                
	LUTC                      
	Llevel                    
	LstdFlags = Ldate | Ltime | Llevel
	LstdNull  = 0                     
)
```

To start things off, `iota` is a value set to 0 whenever it is called in a `const` declaration. The reason it exists is to make defining incrementing numbers easier [source](https://github.com/golang/go/wiki/Iota). So how does this make incrementing numbers easier? Here `iota` is set to 1, and then the `<<` operator is called on it. This means that every successive option called will be [bitshifted](https://stackoverflow.com/questions/5801008/go-and-operators) one place left. What is bitshifting? In order to understand that, it requires a bit of background on how the binary number system works, but I won't go back that far.

So a bitshift left takes the current number and moves it left one place in a binary notation. An example is useful:

`00000001` bitshifted left becomes `00000010`. It changes the value of the bit from 1 to 2.

There is plenty more about bitshifting, including right shifts, but I won't go into those details because there is still one more important mystery in that above `const`. What does `LstdFlags = Ldate | Ltime | Llevel` mean?

The `|` operator is a bitewise "or". As simply as possible, it's like adding numbers together. So using the knowledge from bitshifting left written above we can gather that `LstdFlags = 1 + 2 + 64`. This is because `Ldate` is started at one with a left bitshift of 0 (remember that iota is initialized at 0 and then incremented for each declaration), which keeps the value at 1. Then `Ltime` is again 1, but bitshifted once now, which changes the value from 1 to 2. `Llevel` is bitshifted a total of 6 times. So the bits look like `00000001` to `01000000` or from 1 to 64. Add them all up and you get 67. So If I want to turn in the `LstdFlags` option, the "flag" field in my JSON object should be 67.

## Implementing a controller for an MVC web application

### What I learned

* A handler in Go is a lot like a router in the Zend 3 framework, but more.

### Detail - Implementing a controller for an MVC web application

For disclosure, the book that I am reading to teach myself to program is [Go Web Programming](https://www.amazon.com/Web-Programming-Sau-Sheong-Chang/dp/1617292567). It's also great how impressively commented the go standard library source code is: https://golang.org/pkg/net/http/. However, I'd say that the book is probably one level above my current programming skill. It could be a good thing that I'm challenging myself, but I worry about learning one concept without first mastering the underlying concept. So I will only talk about what a handler is.

Anything that has this method, and method signature implements the handler interface: `ServeHTTP(http.ResponseWriter, *http.Request)`. What is being done is a pointer to an HTTP request comes in (like a "GET"), and then a ResponseWriter will react to that request and return _write_ or return something. Pseudo-code would look like:

```
someFunction(http.ResponseWriter, *http.Request) {
    //a request is recieved
    //do something, parse the URL or parse a payload
    //return some result
}
```

You can declare multiple handlers, which all will be programmed to respond to a certain request being made to the HTTP server, and then attach these handlers to something called a multiplexer. This multiplexer is used to forward a request to the correct handler so that the end user gets the dessired content back. So if you have a handler which responds to "/" and a handler which responds to "/somePage", a request to "/" will be sent to the HTTP server. This HTTP server is using a multiplexer. The multiplexer will then forward that request to the appropriate handler for someone doing a request to "/somePage".

The way that I understand it, is that it is very similar to the way routes work in Angular and Zend frameworks. Both of which I only half remember from a couple of years ago.

## Designing a database scheme

### What I learned

* Not much, I only made 3 simple tables. 

### Detail - Designing a database scheme

https://github.com/thaniri/repotracker-db/commit/22d8993b18d6cf63592d6bd60b2f3680f979324b

One thing noteworthy is that I wanted to see the feasability of using JSON as a column in a table. Primarily for the list of repos that a user is subscribing to, but skipped over the idea because the docker MariaDB container that I am using doesn't support JSON operations like `CHECK (JSON_VALID(attr)));` I got that information from here: https://mariadb.com/resources/blog/json-mariadb-102 . The docker container I am using is the latest from here: https://hub.docker.com/_/mariadb/.

In any case, it would be poor data normalization for me to do that anyway, so it's probably a good thing I didn't try it.
